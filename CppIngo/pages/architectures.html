<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <title>Процессор: сведения общего характера</title>
    <link rel="stylesheet" href="../assets/css/style.css" </head>

<body>
    <h1>
        <a name="01"></a>
        Процессор: сведения общего характера
    </h1>

    <hr />

    <h2>
        <a name="02"></a>
        Архитектура как совместимость с кодом
    </h2>

    <p>
        Наверняка вы часто встречались с термином «<span class="cite">x86</span>»,
        или «<span class="cite">Intel-совместимый процессор</span>»
        (или «<span class="cite">IBM PC compatible</span>» —
        но это уже по отношению к компьютеру). Иногда также встречается термин
        «<span class="cite">Pentium-совместимый</span>» (почему именно Pentium
        — вы поймете сами чуть позже). Что скрывается за всеми этими названиями?
        На данный момент наиболее корректно с
        точки зрения авторов выглядит следующая простая формулировка:
        современный x86-процессор — это процессор, способный корректно
        исполнять машинный код архитектуры x86-64 (архитектура 32-битных процессоров
        Intel, дополненная 64-битными расширениями от AMD). В первом приближении
        современный x86 — это код, исполняемый процессором i80386 (известным в народе
        как «386-й»), окончательно же основной набор команд 32-битной архитектуры IA32
        сформировался с выходом процессора Intel Pentium Pro (с очень незначительным
        дополнениями в следующих процессорах). Что означает «основной набор» и какие
        есть еще? Для начала ответим на первую часть. «Основной» в данном случае
        означает то, что с помощью исключительно этого набора команд может быть
        написана любая программа для процессора архитектуры x86.<br /><br />
    </p>

    <hr>
    <table>
        <caption>Таблица №1 - сравнение процессоров</caption>

        <tr>
            <th>Процессор</th>
            <th>Год выпуска</th>
            <th>x86-64</th>
            <th>MMX</th>
        </tr>
        <tr>
            <td>Pentium Pro</td>
            <td>1995</td>
            <td>N/A</td>
            <td>N/A</td>

        </tr>
        <tr>
            <td>Pentium MMX</td>
            <td>1997</td>
            <td>N/A</td>
            <td>ЕСТЬ</td>
        </tr>

        <tr>
            <td>Pentium 4</td>
            <td>2004</td>
            <td>ЕСТЬ</td>
            <td>ЕСТЬ</td>
        </tr>

    </table>

    <hr>

    <p> <br><br>
        Кроме того, у архитектуры IA32 существуют «официальные» расширения (дополнительные наборы команд) от
        разработчика самой архитектуры, компании Intel: MMX, многочисленные SSE (вплоть до 4.2) и AVX. Также существуют
        «неофициальные» (не от Intel) расширенные наборы команд: EMMX, 3DNow!, Extended 3DNow!, SSE4.a и XOP — их
        разработала компания AMD. Впрочем, «официальность» и «неофициальность» в данном случае понятие относительное —
        де-факто всё сводится к тому, что некоторые расширения набора команд Intel как разработчик изначального набора
        признаёт, а некоторые — нет, разработчики же программного обеспечения используют то, что им лучше всего
        подходит. В отношении расширенных наборов команд существует правило хорошего тона: прежде чем их использовать,
        программа должна проверить, поддерживает ли их процессор. Иногда отступления от этого правила встречаются (и
        могут приводить к неправильному функционированию программ), но объективно это является проблемой некорректно
        написанной программы, а не процессора.<br /><br />
    </p>

    <p>
        Для чего предназначены дополнительные наборы команд? В первую очередь — для увеличения быстродействия при
        выполнении наиболее частых операций. Одна команда из дополнительного набора, как правило, выполняет действие,
        для которого понадобилась бы небольшая процедура, состоящая из команд основного набора, причём специальная
        команда выполняется процессором быстрее, чем заменяющая её последовательность. Однако в 99% случаев ничего
        такого, чего нельзя было бы сделать с помощью основных команд, команды из дополнительного набора также не
        делают. Таким образом, упомянутая выше программная проверка поддержки дополнительных наборов команд процессором
        должна выполнять очень простую функцию: если, например, процессор поддерживает SSE — значит, считать будем
        быстро и с помощью команд из набора SSE. Если нет — будем считать медленнее, с помощью команд из основного
        набора. Корректно написанная программа обязана действовать именно так. Впрочем, сейчас практически никто не
        проверяет у процессора наличие поддержки MMX, т.к. все CPU, вышедшие за последние 10 лет, этот набор
        поддерживают гарантированно. Для справки приведём табличку, на которой обобщена информация о поддержке различных
        расширенных наборов команд различными десктопными (предназначенными для настольных ПК) и некоторыми мобильными
        процессорами.
    </p>


    <h3>
        <a name="03"></a>
        Архитектура как характеристика семейства процессоров
    </h3>

    <p>
        «<span class="cite">Железячники</span>» — люди, работающие в основном не с программным обеспечением, а с
        аппаратным — под «архитектурой» понимают несколько другое (правда, более корректно то, что они называют «<span
            class="cite">архитектурой</span>», называется «<span class="cite">микроархитектурой</span>», но приставку
        «<span class="cite">микро</span>» частенько опускают). Для них «<span class="cite">архитектура CPU</span>» — это
        некий набор свойств, присущий целому семейству процессоров, как правило, выпускаемому в течение многих лет
        (иначе говоря — их организация и «<span class="cite">внутренняя конструкция</span>»). Например, любой специалист
        по x86 CPU вам скажет, что процессор с ALU, работающими на удвоенной частоте, QDR-шиной, Trace cache, и,
        возможно, поддержкой технологии Hyper-Threading — это «<span class="cite">процессор архитектуры NetBurst</span>»
        (не пугайтесь незнакомых терминов — все нужные будут разъяснены чуть позже). Таким образом, понятие «<span
            class="cite">архитектуры</span>» применительно к процессорам двойственно: под ним может пониматься как
        совместимость с единым набором команд, так и совокупность аппаратных решений, присущих определённой достаточно
        широкой группе процессоров.
    </p>

    <h3>
        <a name="04"></a>
        64-битные расширения классической x86 (IA32) архитектуры
    </h3>

    <p>
        В 2003 г. сначала AMD, а через год — и Intel, анонсировали практически идентичные технологии (впрочем, AMD
        предпочитает называть это архитектурой), благодаря которым классические x86 (IA32) CPU получили статус
        64-битных. В случае с AMD данная технология получила наименование «<span class="cite">AMD64</span>», в случае с
        Intel — сначала «<span class="cite">EM64T</span>», а теперь Intel 64. Впрочем, сегодня часто указывают
        нейтральное «<span class="cite">x86-64</span>» — как общее обозначение всех 64-битных расширений архитектуры
        x86, не привязанное к зарегистрированным торговым маркам. Употребление одного из трёх приведённых наименований
        зависит больше от личных предпочтений употребляющего, чем от фактических различий — ибо различия между AMD64 и
        EM64T умещаются на кончике очень тонкой иглы. Так или иначе, всё сводится к следующему: все целочисленные
        регистры (общего назначения) стали вместо 32-битных 64-битными, число регистров (и общих, и векторных)
        удвоилось, 32-битные команды x86-кода получили свои 64-битные аналоги, а объём адресуемой памяти (и физической,
        и виртуальной) многократно увеличился (за счёт того, что логический адрес приобрёл вместо 32-битного 64-битный
        формат). Количество маркетинговых спекуляций на тему «<span class="cite">64-битности</span>» превысило все
        разумные пределы, поэтому следует рассмотреть достоинства данного нововведения.<br /><br />
    </p>

    <p>
        Что не изменилось? В первую очередь — быстродействие процессоров. Вопиющей глупостью будет считать, что один и
        тот же процессор при переходе из привычного 32-битного в 64-битный режим (а 32-битный режим все нынешние x86 CPU
        поддерживают в обязательном порядке) станет работать вдвое быстрее. Разумеется, в некоторых случаях ускорение от
        использования 64-битной целочисленной арифметики может присутствовать — но количество этих случаев сильно
        ограничено, и большинства современного пользовательского программного обеспечения они никак не касаются. Кстати:
        а почему мы употребили термин «<span class="cite">64-битная целочисленная арифметика</span>»? А потому, что
        блоки операций с плавающей точкой (см. ниже) во всех x86-процессорах уже давным-давно не 32-битные. И даже не
        64-битные. Классический вещественный вычислитель, окончательно ставший частью CPU ещё во времена старого доброго
        32-битного Intel Pentium* — уже был 80-битным (и до сих пор таков). Векторные операнды команд SSE (с любой
        цифрой) — и вовсе 128-битные! В этом плане архитектура x86 достаточно парадоксальна: притом, что формально
        процессоры данной архитектуры достаточно долгое время оставались 32-битными — разрядность тех блоков, где «<span
            class="cite">большая битность</span>» была реально необходима — наращивалась совершенно независимо от
        остальных (более подробно о проблеме разрядности процессоров можно почитать в отдельном материале). Например,
        процессоры AMD Athlon XP и Intel Pentium 4 «<span class="cite">Northwood</span>» совмещали в себе блоки,
        работающие с 32-битными, 80-битными, и 128-битными операндами. 32-битными оставались лишь основной набор команд
        (унаследованный от первого процессора архитектуры IA32 — Intel 386) и адресация памяти (максимум 4 гигабайта,
        если не считать «<span class="cite">эквилибристического выверта</span>» от Intel — Physical Address Extension,
        позволявшего «<span class="cite">32-битным</span>» процессорам использовать 36(!)-битную адресацию).<br /><br />
    </p>

    <blockquote>
        * — первым x86 CPU, в который был интегрирован FPU (ранее он устанавливался на плату в качестве отдельного
        чипа), стал процессор предыдущего поколения — i486DX. Но в линейке i486 всё-таки присутствовал i486SX, в состав
        которого FPU не входил. Начиная с Pentium, Intel больше не выпускала x86 CPU без FPU, и эту моду быстро
        подхватили все остальные производители.
    </blockquote>

    <p>
        <br /><br />
        Таким образом, то, что процессоры AMD и Intel стали «<span class="cite">формально 64-битными</span>», на
        практике принесло нам лишь три усовершенствования: появление команд для работы с 64-битными целыми числами,
        увеличение количества и/или разрядности регистров, и увеличение максимального объёма адресуемой памяти. Заметим:
        реальной пользы этих нововведений (особенно третьего!) никто не отрицает. Равно как никто не отрицает заслуг
        компании AMD в продвижении идеи «<span class="cite">осовременивания</span>» (за счёт введения 64-битности)
        x86-процессоров. Мы лишь хотим предостеречь от чрезмерных ожиданий: не стоит надеяться на то, что компьютер,
        покупавшийся «<span class="cite">в ценовом классе ВАЗа</span>», от установки 64-битного программного обеспечения
        станет «<span class="cite">лихим Мерседесом</span>». Чудес на свете не бывает...
    </p>



    <hr />
    <button><a href="ram.html"><<</a></button>
    <button class="nextTXTBtn"><a href="kernel.html">>></a></button>
            

</body>

</html>